{"version":3,"file":"svelte-apollo.es.js","sources":["../src/context.ts","../src/restore.ts","../src/query.ts","../src/mutate.ts","../src/subscribe.ts"],"sourcesContent":["import { getContext, setContext } from 'svelte';\nimport ApolloClient from 'apollo-client';\n\nconst CLIENT = typeof Symbol !== 'undefined' ? Symbol('client') : '@@client';\n\nexport function getClient<TCache = any>(): ApolloClient<TCache> | undefined {\n  return getContext(CLIENT);\n}\n\nexport function setClient<TCache = any>(client: ApolloClient<TCache>): void {\n  setContext(CLIENT, client);\n}\n","import { onMount } from 'svelte';\nimport ApolloClient, { OperationVariables } from 'apollo-client';\nimport { DataProxy } from 'apollo-cache';\n\nexport type Restoring<TCache> =\n  | WeakSet<ApolloClient<TCache>>\n  | Set<ApolloClient<TCache>>;\n\nexport const restoring: Restoring<any> =\n  typeof WeakSet !== 'undefined' ? new WeakSet() : new Set();\n\nexport default function restore<TCache = any, TData = any, TVariables = OperationVariables>(\n  client: ApolloClient<TCache>,\n  options: DataProxy.WriteQueryOptions<TData, TVariables>,\n): void {\n  restoring.add(client);\n  afterHydrate(() => {\n    restoring.delete(client);\n  });\n\n  client.writeQuery(options);\n}\n\nfunction afterHydrate(callback: () => void): void {\n  // Attempt to wait for onMount (hydration of current component is complete),\n  // but if that fails (e.g. outside of component initialization)\n  // wait for next event loop for hydrate to complete\n\n  try {\n    onMount(callback);\n  } catch (_error) {\n    setTimeout(callback, 1);\n  }\n}\n","import { isEqual } from 'apollo-utilities';\nimport { readable } from 'svelte/store';\nimport { observe } from 'svelte-observable';\nimport { restoring } from './restore';\nimport ApolloClient, {\n  ObservableQuery,\n  WatchQueryOptions,\n  ApolloQueryResult\n} from 'apollo-client';\nimport { Deferred, Next, Unsubscribe } from './types';\n\nexport interface QueryStore<TData = any> {\n  subscribe: (\n    subscription: Next<Deferred<ApolloQueryResult<TData>>>\n  ) => Unsubscribe;\n\n  // Most likely extension from ObservableQuery needed\n  refetch: ObservableQuery['refetch'];\n\n  // Rest included for completeness\n  // (except for setVariables, marked internal use only)\n  result: ObservableQuery['result'];\n  fetchMore: ObservableQuery['fetchMore'];\n  setOptions: ObservableQuery['setOptions'];\n  updateQuery: ObservableQuery['updateQuery'];\n  startPolling: ObservableQuery['startPolling'];\n  stopPolling: ObservableQuery['stopPolling'];\n  subscribeToMore: ObservableQuery['subscribeToMore'];\n}\n\nexport default function query<TData = any, TCache = any, TVariables = any>(\n  client: ApolloClient<TCache>,\n  options: WatchQueryOptions<TVariables>\n): QueryStore<TData> {\n  type Value = ApolloQueryResult<TData>;\n\n  let subscribed = false;\n  let initial_value: Value | undefined;\n\n  // If client is restoring (e.g. from SSR)\n  // attempt synchronous readQuery first (to prevent loading in {#await})\n  if (restoring.has(client)) {\n    try {\n      // undefined = skip initial value (not in cache)\n      initial_value = client.readQuery(options) || undefined;\n      initial_value = { data: initial_value } as any;\n    } catch (err) {\n      // Ignore preload errors\n    }\n  }\n\n  // Create query and observe,\n  // but don't subscribe directly to avoid firing duplicate value if initialized\n  const observable_query = client.watchQuery<TData>(options);\n  const { subscribe: subscribe_to_query } = observe<Value>(\n    observable_query,\n    initial_value\n  );\n\n  // Wrap the query subscription with a readable to prevent duplicate values\n  const { subscribe } = readable(\n    (initial_value as unknown) as Deferred<Value>,\n    set => {\n      subscribed = true;\n\n      const skip_duplicate = initial_value !== undefined;\n      let initialized = false;\n      let skipped = false;\n\n      const unsubscribe = subscribe_to_query(value => {\n        if (skip_duplicate && initialized && !skipped) {\n          skipped = true;\n        } else {\n          if (!initialized) initialized = true;\n          set(value);\n        }\n      });\n\n      return unsubscribe;\n    }\n  );\n\n  return {\n    subscribe,\n    refetch: variables => {\n      // If variables have not changed and not subscribed, skip refetch\n      if (!subscribed && isEqual(variables, observable_query.variables))\n        return observable_query.result();\n\n      return observable_query.refetch(variables);\n    },\n    result: () => observable_query.result(),\n    fetchMore: options => observable_query.fetchMore(options),\n    setOptions: options => observable_query.setOptions(options),\n    updateQuery: map => observable_query.updateQuery(map),\n    startPolling: interval => observable_query.startPolling(interval),\n    stopPolling: () => observable_query.stopPolling(),\n    subscribeToMore: options => observable_query.subscribeToMore(options)\n  };\n}\n","import ApolloClient, { MutationOptions } from 'apollo-client';\nimport { FetchResult } from 'apollo-link';\n\nexport default function mutate<T = any, TCache = any, TVariables = any>(\n  client: ApolloClient<TCache>,\n  options: MutationOptions<T, TVariables>\n): Promise<FetchResult<T>> {\n  return client.mutate(options);\n}\n","import { observe } from 'svelte-observable';\nimport ApolloClient, { SubscriptionOptions } from 'apollo-client';\nimport { Deferred, Next, Unsubscribe } from './types';\n\nexport interface ReadableStore<T> {\n  subscribe(next: Next<T>): Unsubscribe;\n}\n\nexport default function subscribe<TCache = any, TVariables = any, T = any>(\n  client: ApolloClient<TCache>,\n  options: SubscriptionOptions<TVariables>\n): ReadableStore<Deferred<T>> {\n  const observable = client.subscribe(options);\n  return observe<T>(observable);\n}\n"],"names":[],"mappings":";;;;;AAGA,IAAM,MAAM,GAAG,OAAO,MAAM,KAAK,WAAW,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,UAAU,CAAC;AAE7E,SAAgB,SAAS;IACvB,OAAO,UAAU,CAAC,MAAM,CAAC,CAAC;CAC3B;AAED,SAAgB,SAAS,CAAe,MAA4B;IAClE,UAAU,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;CAC5B;;ACHM,IAAM,SAAS,GACpB,OAAO,OAAO,KAAK,WAAW,GAAG,IAAI,OAAO,EAAE,GAAG,IAAI,GAAG,EAAE,CAAC;AAE7D,SAAwB,OAAO,CAC7B,MAA4B,EAC5B,OAAuD;IAEvD,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACtB,YAAY,CAAC;QACX,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;KAC1B,CAAC,CAAC;IAEH,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;CAC5B;AAED,SAAS,YAAY,CAAC,QAAoB;;;;IAKxC,IAAI;QACF,OAAO,CAAC,QAAQ,CAAC,CAAC;KACnB;IAAC,OAAO,MAAM,EAAE;QACf,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;KACzB;CACF;;SCHuB,KAAK,CAC3B,MAA4B,EAC5B,OAAsC;IAItC,IAAI,UAAU,GAAG,KAAK,CAAC;IACvB,IAAI,aAAgC,CAAC;;;IAIrC,IAAI,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;QACzB,IAAI;;YAEF,aAAa,GAAG,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,SAAS,CAAC;YACvD,aAAa,GAAG,EAAE,IAAI,EAAE,aAAa,EAAS,CAAC;SAChD;QAAC,OAAO,GAAG,EAAE;;SAEb;KACF;;;IAID,IAAM,gBAAgB,GAAG,MAAM,CAAC,UAAU,CAAQ,OAAO,CAAC,CAAC;IACnD,IAAA,uEAA6B,CAGnC;;IAGM,IAAA;;;;;;;;;;;;;;;;gBAAS,CAoBf;IAEF,OAAO;QACL,SAAS,WAAA;QACT,OAAO,EAAE,UAAA,SAAS;;YAEhB,IAAI,CAAC,UAAU,IAAI,OAAO,CAAC,SAAS,EAAE,gBAAgB,CAAC,SAAS,CAAC;gBAC/D,OAAO,gBAAgB,CAAC,MAAM,EAAE,CAAC;YAEnC,OAAO,gBAAgB,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;SAC5C;QACD,MAAM,EAAE,cAAM,OAAA,gBAAgB,CAAC,MAAM,EAAE,GAAA;QACvC,SAAS,EAAE,UAAA,OAAO,IAAI,OAAA,gBAAgB,CAAC,SAAS,CAAC,OAAO,CAAC,GAAA;QACzD,UAAU,EAAE,UAAA,OAAO,IAAI,OAAA,gBAAgB,CAAC,UAAU,CAAC,OAAO,CAAC,GAAA;QAC3D,WAAW,EAAE,UAAA,GAAG,IAAI,OAAA,gBAAgB,CAAC,WAAW,CAAC,GAAG,CAAC,GAAA;QACrD,YAAY,EAAE,UAAA,QAAQ,IAAI,OAAA,gBAAgB,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAA;QACjE,WAAW,EAAE,cAAM,OAAA,gBAAgB,CAAC,WAAW,EAAE,GAAA;QACjD,eAAe,EAAE,UAAA,OAAO,IAAI,OAAA,gBAAgB,CAAC,eAAe,CAAC,OAAO,CAAC,GAAA;KACtE,CAAC;CACH;;SChGuB,MAAM,CAC5B,MAA4B,EAC5B,OAAuC;IAEvC,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;CAC/B;;SCAuB,SAAS,CAC/B,MAA4B,EAC5B,OAAwC;IAExC,IAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAC7C,OAAO,OAAO,CAAI,UAAU,CAAC,CAAC;CAC/B;;;;"}